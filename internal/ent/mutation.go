// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"online-teaching/internal/ent/course"
	"online-teaching/internal/ent/coursechapter"
	"online-teaching/internal/ent/courseinfo"
	"online-teaching/internal/ent/coursesection"
	"online-teaching/internal/ent/courseteacher"
	"online-teaching/internal/ent/predicate"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCourse        = "Course"
	TypeCourseChapter = "CourseChapter"
	TypeCourseInfo    = "CourseInfo"
	TypeCourseSection = "CourseSection"
	TypeCourseTeacher = "CourseTeacher"
)

// CourseMutation represents an operation that mutates the Course nodes in the graph.
type CourseMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	name                  *string
	desc                  *string
	background_image      *string
	is_deleted            *bool
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	clearedFields         map[string]struct{}
	course_teacher        map[int]struct{}
	removedcourse_teacher map[int]struct{}
	clearedcourse_teacher bool
	course_info           map[int]struct{}
	removedcourse_info    map[int]struct{}
	clearedcourse_info    bool
	course_chapter        map[int]struct{}
	removedcourse_chapter map[int]struct{}
	clearedcourse_chapter bool
	course_section        map[int]struct{}
	removedcourse_section map[int]struct{}
	clearedcourse_section bool
	done                  bool
	oldValue              func(context.Context) (*Course, error)
	predicates            []predicate.Course
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows management of the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for the Course entity.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the ID field of the mutation.
func withCourseID(id int) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Course.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CourseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CourseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CourseMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *CourseMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *CourseMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *CourseMutation) ResetDesc() {
	m.desc = nil
}

// SetBackgroundImage sets the "background_image" field.
func (m *CourseMutation) SetBackgroundImage(s string) {
	m.background_image = &s
}

// BackgroundImage returns the value of the "background_image" field in the mutation.
func (m *CourseMutation) BackgroundImage() (r string, exists bool) {
	v := m.background_image
	if v == nil {
		return
	}
	return *v, true
}

// OldBackgroundImage returns the old "background_image" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldBackgroundImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackgroundImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackgroundImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackgroundImage: %w", err)
	}
	return oldValue.BackgroundImage, nil
}

// ResetBackgroundImage resets all changes to the "background_image" field.
func (m *CourseMutation) ResetBackgroundImage() {
	m.background_image = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *CourseMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *CourseMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *CourseMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CourseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CourseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CourseMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// AddCourseTeacherIDs adds the "course_teacher" edge to the CourseTeacher entity by ids.
func (m *CourseMutation) AddCourseTeacherIDs(ids ...int) {
	if m.course_teacher == nil {
		m.course_teacher = make(map[int]struct{})
	}
	for i := range ids {
		m.course_teacher[ids[i]] = struct{}{}
	}
}

// ClearCourseTeacher clears the "course_teacher" edge to the CourseTeacher entity.
func (m *CourseMutation) ClearCourseTeacher() {
	m.clearedcourse_teacher = true
}

// CourseTeacherCleared reports if the "course_teacher" edge to the CourseTeacher entity was cleared.
func (m *CourseMutation) CourseTeacherCleared() bool {
	return m.clearedcourse_teacher
}

// RemoveCourseTeacherIDs removes the "course_teacher" edge to the CourseTeacher entity by IDs.
func (m *CourseMutation) RemoveCourseTeacherIDs(ids ...int) {
	if m.removedcourse_teacher == nil {
		m.removedcourse_teacher = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.course_teacher, ids[i])
		m.removedcourse_teacher[ids[i]] = struct{}{}
	}
}

// RemovedCourseTeacher returns the removed IDs of the "course_teacher" edge to the CourseTeacher entity.
func (m *CourseMutation) RemovedCourseTeacherIDs() (ids []int) {
	for id := range m.removedcourse_teacher {
		ids = append(ids, id)
	}
	return
}

// CourseTeacherIDs returns the "course_teacher" edge IDs in the mutation.
func (m *CourseMutation) CourseTeacherIDs() (ids []int) {
	for id := range m.course_teacher {
		ids = append(ids, id)
	}
	return
}

// ResetCourseTeacher resets all changes to the "course_teacher" edge.
func (m *CourseMutation) ResetCourseTeacher() {
	m.course_teacher = nil
	m.clearedcourse_teacher = false
	m.removedcourse_teacher = nil
}

// AddCourseInfoIDs adds the "course_info" edge to the CourseInfo entity by ids.
func (m *CourseMutation) AddCourseInfoIDs(ids ...int) {
	if m.course_info == nil {
		m.course_info = make(map[int]struct{})
	}
	for i := range ids {
		m.course_info[ids[i]] = struct{}{}
	}
}

// ClearCourseInfo clears the "course_info" edge to the CourseInfo entity.
func (m *CourseMutation) ClearCourseInfo() {
	m.clearedcourse_info = true
}

// CourseInfoCleared reports if the "course_info" edge to the CourseInfo entity was cleared.
func (m *CourseMutation) CourseInfoCleared() bool {
	return m.clearedcourse_info
}

// RemoveCourseInfoIDs removes the "course_info" edge to the CourseInfo entity by IDs.
func (m *CourseMutation) RemoveCourseInfoIDs(ids ...int) {
	if m.removedcourse_info == nil {
		m.removedcourse_info = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.course_info, ids[i])
		m.removedcourse_info[ids[i]] = struct{}{}
	}
}

// RemovedCourseInfo returns the removed IDs of the "course_info" edge to the CourseInfo entity.
func (m *CourseMutation) RemovedCourseInfoIDs() (ids []int) {
	for id := range m.removedcourse_info {
		ids = append(ids, id)
	}
	return
}

// CourseInfoIDs returns the "course_info" edge IDs in the mutation.
func (m *CourseMutation) CourseInfoIDs() (ids []int) {
	for id := range m.course_info {
		ids = append(ids, id)
	}
	return
}

// ResetCourseInfo resets all changes to the "course_info" edge.
func (m *CourseMutation) ResetCourseInfo() {
	m.course_info = nil
	m.clearedcourse_info = false
	m.removedcourse_info = nil
}

// AddCourseChapterIDs adds the "course_chapter" edge to the CourseChapter entity by ids.
func (m *CourseMutation) AddCourseChapterIDs(ids ...int) {
	if m.course_chapter == nil {
		m.course_chapter = make(map[int]struct{})
	}
	for i := range ids {
		m.course_chapter[ids[i]] = struct{}{}
	}
}

// ClearCourseChapter clears the "course_chapter" edge to the CourseChapter entity.
func (m *CourseMutation) ClearCourseChapter() {
	m.clearedcourse_chapter = true
}

// CourseChapterCleared reports if the "course_chapter" edge to the CourseChapter entity was cleared.
func (m *CourseMutation) CourseChapterCleared() bool {
	return m.clearedcourse_chapter
}

// RemoveCourseChapterIDs removes the "course_chapter" edge to the CourseChapter entity by IDs.
func (m *CourseMutation) RemoveCourseChapterIDs(ids ...int) {
	if m.removedcourse_chapter == nil {
		m.removedcourse_chapter = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.course_chapter, ids[i])
		m.removedcourse_chapter[ids[i]] = struct{}{}
	}
}

// RemovedCourseChapter returns the removed IDs of the "course_chapter" edge to the CourseChapter entity.
func (m *CourseMutation) RemovedCourseChapterIDs() (ids []int) {
	for id := range m.removedcourse_chapter {
		ids = append(ids, id)
	}
	return
}

// CourseChapterIDs returns the "course_chapter" edge IDs in the mutation.
func (m *CourseMutation) CourseChapterIDs() (ids []int) {
	for id := range m.course_chapter {
		ids = append(ids, id)
	}
	return
}

// ResetCourseChapter resets all changes to the "course_chapter" edge.
func (m *CourseMutation) ResetCourseChapter() {
	m.course_chapter = nil
	m.clearedcourse_chapter = false
	m.removedcourse_chapter = nil
}

// AddCourseSectionIDs adds the "course_section" edge to the CourseSection entity by ids.
func (m *CourseMutation) AddCourseSectionIDs(ids ...int) {
	if m.course_section == nil {
		m.course_section = make(map[int]struct{})
	}
	for i := range ids {
		m.course_section[ids[i]] = struct{}{}
	}
}

// ClearCourseSection clears the "course_section" edge to the CourseSection entity.
func (m *CourseMutation) ClearCourseSection() {
	m.clearedcourse_section = true
}

// CourseSectionCleared reports if the "course_section" edge to the CourseSection entity was cleared.
func (m *CourseMutation) CourseSectionCleared() bool {
	return m.clearedcourse_section
}

// RemoveCourseSectionIDs removes the "course_section" edge to the CourseSection entity by IDs.
func (m *CourseMutation) RemoveCourseSectionIDs(ids ...int) {
	if m.removedcourse_section == nil {
		m.removedcourse_section = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.course_section, ids[i])
		m.removedcourse_section[ids[i]] = struct{}{}
	}
}

// RemovedCourseSection returns the removed IDs of the "course_section" edge to the CourseSection entity.
func (m *CourseMutation) RemovedCourseSectionIDs() (ids []int) {
	for id := range m.removedcourse_section {
		ids = append(ids, id)
	}
	return
}

// CourseSectionIDs returns the "course_section" edge IDs in the mutation.
func (m *CourseMutation) CourseSectionIDs() (ids []int) {
	for id := range m.course_section {
		ids = append(ids, id)
	}
	return
}

// ResetCourseSection resets all changes to the "course_section" edge.
func (m *CourseMutation) ResetCourseSection() {
	m.course_section = nil
	m.clearedcourse_section = false
	m.removedcourse_section = nil
}

// Where appends a list predicates to the CourseMutation builder.
func (m *CourseMutation) Where(ps ...predicate.Course) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, course.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, course.FieldDesc)
	}
	if m.background_image != nil {
		fields = append(fields, course.FieldBackgroundImage)
	}
	if m.is_deleted != nil {
		fields = append(fields, course.FieldIsDeleted)
	}
	if m.created_at != nil {
		fields = append(fields, course.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, course.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, course.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldName:
		return m.Name()
	case course.FieldDesc:
		return m.Desc()
	case course.FieldBackgroundImage:
		return m.BackgroundImage()
	case course.FieldIsDeleted:
		return m.IsDeleted()
	case course.FieldCreatedAt:
		return m.CreatedAt()
	case course.FieldUpdatedAt:
		return m.UpdatedAt()
	case course.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldName:
		return m.OldName(ctx)
	case course.FieldDesc:
		return m.OldDesc(ctx)
	case course.FieldBackgroundImage:
		return m.OldBackgroundImage(ctx)
	case course.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case course.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case course.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case course.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case course.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case course.FieldBackgroundImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackgroundImage(v)
		return nil
	case course.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case course.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case course.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case course.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldName:
		m.ResetName()
		return nil
	case course.FieldDesc:
		m.ResetDesc()
		return nil
	case course.FieldBackgroundImage:
		m.ResetBackgroundImage()
		return nil
	case course.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case course.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case course.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case course.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.course_teacher != nil {
		edges = append(edges, course.EdgeCourseTeacher)
	}
	if m.course_info != nil {
		edges = append(edges, course.EdgeCourseInfo)
	}
	if m.course_chapter != nil {
		edges = append(edges, course.EdgeCourseChapter)
	}
	if m.course_section != nil {
		edges = append(edges, course.EdgeCourseSection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeCourseTeacher:
		ids := make([]ent.Value, 0, len(m.course_teacher))
		for id := range m.course_teacher {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeCourseInfo:
		ids := make([]ent.Value, 0, len(m.course_info))
		for id := range m.course_info {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeCourseChapter:
		ids := make([]ent.Value, 0, len(m.course_chapter))
		for id := range m.course_chapter {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeCourseSection:
		ids := make([]ent.Value, 0, len(m.course_section))
		for id := range m.course_section {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcourse_teacher != nil {
		edges = append(edges, course.EdgeCourseTeacher)
	}
	if m.removedcourse_info != nil {
		edges = append(edges, course.EdgeCourseInfo)
	}
	if m.removedcourse_chapter != nil {
		edges = append(edges, course.EdgeCourseChapter)
	}
	if m.removedcourse_section != nil {
		edges = append(edges, course.EdgeCourseSection)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeCourseTeacher:
		ids := make([]ent.Value, 0, len(m.removedcourse_teacher))
		for id := range m.removedcourse_teacher {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeCourseInfo:
		ids := make([]ent.Value, 0, len(m.removedcourse_info))
		for id := range m.removedcourse_info {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeCourseChapter:
		ids := make([]ent.Value, 0, len(m.removedcourse_chapter))
		for id := range m.removedcourse_chapter {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeCourseSection:
		ids := make([]ent.Value, 0, len(m.removedcourse_section))
		for id := range m.removedcourse_section {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcourse_teacher {
		edges = append(edges, course.EdgeCourseTeacher)
	}
	if m.clearedcourse_info {
		edges = append(edges, course.EdgeCourseInfo)
	}
	if m.clearedcourse_chapter {
		edges = append(edges, course.EdgeCourseChapter)
	}
	if m.clearedcourse_section {
		edges = append(edges, course.EdgeCourseSection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	case course.EdgeCourseTeacher:
		return m.clearedcourse_teacher
	case course.EdgeCourseInfo:
		return m.clearedcourse_info
	case course.EdgeCourseChapter:
		return m.clearedcourse_chapter
	case course.EdgeCourseSection:
		return m.clearedcourse_section
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeCourseTeacher:
		m.ResetCourseTeacher()
		return nil
	case course.EdgeCourseInfo:
		m.ResetCourseInfo()
		return nil
	case course.EdgeCourseChapter:
		m.ResetCourseChapter()
		return nil
	case course.EdgeCourseSection:
		m.ResetCourseSection()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// CourseChapterMutation represents an operation that mutates the CourseChapter nodes in the graph.
type CourseChapterMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	title                 *string
	is_deleted            *bool
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	clearedFields         map[string]struct{}
	course_section        map[int]struct{}
	removedcourse_section map[int]struct{}
	clearedcourse_section bool
	done                  bool
	oldValue              func(context.Context) (*CourseChapter, error)
	predicates            []predicate.CourseChapter
}

var _ ent.Mutation = (*CourseChapterMutation)(nil)

// coursechapterOption allows management of the mutation configuration using functional options.
type coursechapterOption func(*CourseChapterMutation)

// newCourseChapterMutation creates new mutation for the CourseChapter entity.
func newCourseChapterMutation(c config, op Op, opts ...coursechapterOption) *CourseChapterMutation {
	m := &CourseChapterMutation{
		config:        c,
		op:            op,
		typ:           TypeCourseChapter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseChapterID sets the ID field of the mutation.
func withCourseChapterID(id int) coursechapterOption {
	return func(m *CourseChapterMutation) {
		var (
			err   error
			once  sync.Once
			value *CourseChapter
		)
		m.oldValue = func(ctx context.Context) (*CourseChapter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CourseChapter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourseChapter sets the old CourseChapter of the mutation.
func withCourseChapter(node *CourseChapter) coursechapterOption {
	return func(m *CourseChapterMutation) {
		m.oldValue = func(context.Context) (*CourseChapter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseChapterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseChapterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseChapterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseChapterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CourseChapter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *CourseChapterMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CourseChapterMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the CourseChapter entity.
// If the CourseChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseChapterMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CourseChapterMutation) ResetTitle() {
	m.title = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *CourseChapterMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *CourseChapterMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the CourseChapter entity.
// If the CourseChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseChapterMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *CourseChapterMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseChapterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseChapterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CourseChapter entity.
// If the CourseChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseChapterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseChapterMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseChapterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseChapterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CourseChapter entity.
// If the CourseChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseChapterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseChapterMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CourseChapterMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CourseChapterMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CourseChapter entity.
// If the CourseChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseChapterMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CourseChapterMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// AddCourseSectionIDs adds the "course_section" edge to the CourseSection entity by ids.
func (m *CourseChapterMutation) AddCourseSectionIDs(ids ...int) {
	if m.course_section == nil {
		m.course_section = make(map[int]struct{})
	}
	for i := range ids {
		m.course_section[ids[i]] = struct{}{}
	}
}

// ClearCourseSection clears the "course_section" edge to the CourseSection entity.
func (m *CourseChapterMutation) ClearCourseSection() {
	m.clearedcourse_section = true
}

// CourseSectionCleared reports if the "course_section" edge to the CourseSection entity was cleared.
func (m *CourseChapterMutation) CourseSectionCleared() bool {
	return m.clearedcourse_section
}

// RemoveCourseSectionIDs removes the "course_section" edge to the CourseSection entity by IDs.
func (m *CourseChapterMutation) RemoveCourseSectionIDs(ids ...int) {
	if m.removedcourse_section == nil {
		m.removedcourse_section = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.course_section, ids[i])
		m.removedcourse_section[ids[i]] = struct{}{}
	}
}

// RemovedCourseSection returns the removed IDs of the "course_section" edge to the CourseSection entity.
func (m *CourseChapterMutation) RemovedCourseSectionIDs() (ids []int) {
	for id := range m.removedcourse_section {
		ids = append(ids, id)
	}
	return
}

// CourseSectionIDs returns the "course_section" edge IDs in the mutation.
func (m *CourseChapterMutation) CourseSectionIDs() (ids []int) {
	for id := range m.course_section {
		ids = append(ids, id)
	}
	return
}

// ResetCourseSection resets all changes to the "course_section" edge.
func (m *CourseChapterMutation) ResetCourseSection() {
	m.course_section = nil
	m.clearedcourse_section = false
	m.removedcourse_section = nil
}

// Where appends a list predicates to the CourseChapterMutation builder.
func (m *CourseChapterMutation) Where(ps ...predicate.CourseChapter) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CourseChapterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CourseChapter).
func (m *CourseChapterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseChapterMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.title != nil {
		fields = append(fields, coursechapter.FieldTitle)
	}
	if m.is_deleted != nil {
		fields = append(fields, coursechapter.FieldIsDeleted)
	}
	if m.created_at != nil {
		fields = append(fields, coursechapter.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, coursechapter.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, coursechapter.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseChapterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coursechapter.FieldTitle:
		return m.Title()
	case coursechapter.FieldIsDeleted:
		return m.IsDeleted()
	case coursechapter.FieldCreatedAt:
		return m.CreatedAt()
	case coursechapter.FieldUpdatedAt:
		return m.UpdatedAt()
	case coursechapter.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseChapterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coursechapter.FieldTitle:
		return m.OldTitle(ctx)
	case coursechapter.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case coursechapter.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case coursechapter.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case coursechapter.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CourseChapter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseChapterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coursechapter.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case coursechapter.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case coursechapter.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case coursechapter.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case coursechapter.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CourseChapter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseChapterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseChapterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseChapterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CourseChapter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseChapterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseChapterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseChapterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CourseChapter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseChapterMutation) ResetField(name string) error {
	switch name {
	case coursechapter.FieldTitle:
		m.ResetTitle()
		return nil
	case coursechapter.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case coursechapter.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case coursechapter.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case coursechapter.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown CourseChapter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseChapterMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.course_section != nil {
		edges = append(edges, coursechapter.EdgeCourseSection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseChapterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case coursechapter.EdgeCourseSection:
		ids := make([]ent.Value, 0, len(m.course_section))
		for id := range m.course_section {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseChapterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcourse_section != nil {
		edges = append(edges, coursechapter.EdgeCourseSection)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseChapterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case coursechapter.EdgeCourseSection:
		ids := make([]ent.Value, 0, len(m.removedcourse_section))
		for id := range m.removedcourse_section {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseChapterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcourse_section {
		edges = append(edges, coursechapter.EdgeCourseSection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseChapterMutation) EdgeCleared(name string) bool {
	switch name {
	case coursechapter.EdgeCourseSection:
		return m.clearedcourse_section
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseChapterMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CourseChapter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseChapterMutation) ResetEdge(name string) error {
	switch name {
	case coursechapter.EdgeCourseSection:
		m.ResetCourseSection()
		return nil
	}
	return fmt.Errorf("unknown CourseChapter edge %s", name)
}

// CourseInfoMutation represents an operation that mutates the CourseInfo nodes in the graph.
type CourseInfoMutation struct {
	config
	op                Op
	typ               string
	id                *int
	click_count       *int
	addclick_count    *int
	learn_count       *int
	addlearn_count    *int
	total_duration    *int
	addtotal_duration *int
	section_count     *int
	addsection_count  *int
	price             *float64
	addprice          *float64
	detail            *string
	state             *string
	is_deleted        *bool
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*CourseInfo, error)
	predicates        []predicate.CourseInfo
}

var _ ent.Mutation = (*CourseInfoMutation)(nil)

// courseinfoOption allows management of the mutation configuration using functional options.
type courseinfoOption func(*CourseInfoMutation)

// newCourseInfoMutation creates new mutation for the CourseInfo entity.
func newCourseInfoMutation(c config, op Op, opts ...courseinfoOption) *CourseInfoMutation {
	m := &CourseInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeCourseInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseInfoID sets the ID field of the mutation.
func withCourseInfoID(id int) courseinfoOption {
	return func(m *CourseInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *CourseInfo
		)
		m.oldValue = func(ctx context.Context) (*CourseInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CourseInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourseInfo sets the old CourseInfo of the mutation.
func withCourseInfo(node *CourseInfo) courseinfoOption {
	return func(m *CourseInfoMutation) {
		m.oldValue = func(context.Context) (*CourseInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseInfoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CourseInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClickCount sets the "click_count" field.
func (m *CourseInfoMutation) SetClickCount(i int) {
	m.click_count = &i
	m.addclick_count = nil
}

// ClickCount returns the value of the "click_count" field in the mutation.
func (m *CourseInfoMutation) ClickCount() (r int, exists bool) {
	v := m.click_count
	if v == nil {
		return
	}
	return *v, true
}

// OldClickCount returns the old "click_count" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldClickCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClickCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClickCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClickCount: %w", err)
	}
	return oldValue.ClickCount, nil
}

// AddClickCount adds i to the "click_count" field.
func (m *CourseInfoMutation) AddClickCount(i int) {
	if m.addclick_count != nil {
		*m.addclick_count += i
	} else {
		m.addclick_count = &i
	}
}

// AddedClickCount returns the value that was added to the "click_count" field in this mutation.
func (m *CourseInfoMutation) AddedClickCount() (r int, exists bool) {
	v := m.addclick_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetClickCount resets all changes to the "click_count" field.
func (m *CourseInfoMutation) ResetClickCount() {
	m.click_count = nil
	m.addclick_count = nil
}

// SetLearnCount sets the "learn_count" field.
func (m *CourseInfoMutation) SetLearnCount(i int) {
	m.learn_count = &i
	m.addlearn_count = nil
}

// LearnCount returns the value of the "learn_count" field in the mutation.
func (m *CourseInfoMutation) LearnCount() (r int, exists bool) {
	v := m.learn_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLearnCount returns the old "learn_count" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldLearnCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLearnCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLearnCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLearnCount: %w", err)
	}
	return oldValue.LearnCount, nil
}

// AddLearnCount adds i to the "learn_count" field.
func (m *CourseInfoMutation) AddLearnCount(i int) {
	if m.addlearn_count != nil {
		*m.addlearn_count += i
	} else {
		m.addlearn_count = &i
	}
}

// AddedLearnCount returns the value that was added to the "learn_count" field in this mutation.
func (m *CourseInfoMutation) AddedLearnCount() (r int, exists bool) {
	v := m.addlearn_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLearnCount resets all changes to the "learn_count" field.
func (m *CourseInfoMutation) ResetLearnCount() {
	m.learn_count = nil
	m.addlearn_count = nil
}

// SetTotalDuration sets the "total_duration" field.
func (m *CourseInfoMutation) SetTotalDuration(i int) {
	m.total_duration = &i
	m.addtotal_duration = nil
}

// TotalDuration returns the value of the "total_duration" field in the mutation.
func (m *CourseInfoMutation) TotalDuration() (r int, exists bool) {
	v := m.total_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalDuration returns the old "total_duration" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldTotalDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalDuration: %w", err)
	}
	return oldValue.TotalDuration, nil
}

// AddTotalDuration adds i to the "total_duration" field.
func (m *CourseInfoMutation) AddTotalDuration(i int) {
	if m.addtotal_duration != nil {
		*m.addtotal_duration += i
	} else {
		m.addtotal_duration = &i
	}
}

// AddedTotalDuration returns the value that was added to the "total_duration" field in this mutation.
func (m *CourseInfoMutation) AddedTotalDuration() (r int, exists bool) {
	v := m.addtotal_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalDuration resets all changes to the "total_duration" field.
func (m *CourseInfoMutation) ResetTotalDuration() {
	m.total_duration = nil
	m.addtotal_duration = nil
}

// SetSectionCount sets the "section_count" field.
func (m *CourseInfoMutation) SetSectionCount(i int) {
	m.section_count = &i
	m.addsection_count = nil
}

// SectionCount returns the value of the "section_count" field in the mutation.
func (m *CourseInfoMutation) SectionCount() (r int, exists bool) {
	v := m.section_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSectionCount returns the old "section_count" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldSectionCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSectionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSectionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSectionCount: %w", err)
	}
	return oldValue.SectionCount, nil
}

// AddSectionCount adds i to the "section_count" field.
func (m *CourseInfoMutation) AddSectionCount(i int) {
	if m.addsection_count != nil {
		*m.addsection_count += i
	} else {
		m.addsection_count = &i
	}
}

// AddedSectionCount returns the value that was added to the "section_count" field in this mutation.
func (m *CourseInfoMutation) AddedSectionCount() (r int, exists bool) {
	v := m.addsection_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSectionCount resets all changes to the "section_count" field.
func (m *CourseInfoMutation) ResetSectionCount() {
	m.section_count = nil
	m.addsection_count = nil
}

// SetPrice sets the "price" field.
func (m *CourseInfoMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *CourseInfoMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *CourseInfoMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *CourseInfoMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *CourseInfoMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetDetail sets the "detail" field.
func (m *CourseInfoMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *CourseInfoMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ResetDetail resets all changes to the "detail" field.
func (m *CourseInfoMutation) ResetDetail() {
	m.detail = nil
}

// SetState sets the "state" field.
func (m *CourseInfoMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *CourseInfoMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *CourseInfoMutation) ResetState() {
	m.state = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *CourseInfoMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *CourseInfoMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *CourseInfoMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CourseInfoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CourseInfoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CourseInfoMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// Where appends a list predicates to the CourseInfoMutation builder.
func (m *CourseInfoMutation) Where(ps ...predicate.CourseInfo) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CourseInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CourseInfo).
func (m *CourseInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseInfoMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.click_count != nil {
		fields = append(fields, courseinfo.FieldClickCount)
	}
	if m.learn_count != nil {
		fields = append(fields, courseinfo.FieldLearnCount)
	}
	if m.total_duration != nil {
		fields = append(fields, courseinfo.FieldTotalDuration)
	}
	if m.section_count != nil {
		fields = append(fields, courseinfo.FieldSectionCount)
	}
	if m.price != nil {
		fields = append(fields, courseinfo.FieldPrice)
	}
	if m.detail != nil {
		fields = append(fields, courseinfo.FieldDetail)
	}
	if m.state != nil {
		fields = append(fields, courseinfo.FieldState)
	}
	if m.is_deleted != nil {
		fields = append(fields, courseinfo.FieldIsDeleted)
	}
	if m.created_at != nil {
		fields = append(fields, courseinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, courseinfo.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, courseinfo.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case courseinfo.FieldClickCount:
		return m.ClickCount()
	case courseinfo.FieldLearnCount:
		return m.LearnCount()
	case courseinfo.FieldTotalDuration:
		return m.TotalDuration()
	case courseinfo.FieldSectionCount:
		return m.SectionCount()
	case courseinfo.FieldPrice:
		return m.Price()
	case courseinfo.FieldDetail:
		return m.Detail()
	case courseinfo.FieldState:
		return m.State()
	case courseinfo.FieldIsDeleted:
		return m.IsDeleted()
	case courseinfo.FieldCreatedAt:
		return m.CreatedAt()
	case courseinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case courseinfo.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case courseinfo.FieldClickCount:
		return m.OldClickCount(ctx)
	case courseinfo.FieldLearnCount:
		return m.OldLearnCount(ctx)
	case courseinfo.FieldTotalDuration:
		return m.OldTotalDuration(ctx)
	case courseinfo.FieldSectionCount:
		return m.OldSectionCount(ctx)
	case courseinfo.FieldPrice:
		return m.OldPrice(ctx)
	case courseinfo.FieldDetail:
		return m.OldDetail(ctx)
	case courseinfo.FieldState:
		return m.OldState(ctx)
	case courseinfo.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case courseinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case courseinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case courseinfo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CourseInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case courseinfo.FieldClickCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClickCount(v)
		return nil
	case courseinfo.FieldLearnCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLearnCount(v)
		return nil
	case courseinfo.FieldTotalDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalDuration(v)
		return nil
	case courseinfo.FieldSectionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSectionCount(v)
		return nil
	case courseinfo.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case courseinfo.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case courseinfo.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case courseinfo.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case courseinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case courseinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case courseinfo.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CourseInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseInfoMutation) AddedFields() []string {
	var fields []string
	if m.addclick_count != nil {
		fields = append(fields, courseinfo.FieldClickCount)
	}
	if m.addlearn_count != nil {
		fields = append(fields, courseinfo.FieldLearnCount)
	}
	if m.addtotal_duration != nil {
		fields = append(fields, courseinfo.FieldTotalDuration)
	}
	if m.addsection_count != nil {
		fields = append(fields, courseinfo.FieldSectionCount)
	}
	if m.addprice != nil {
		fields = append(fields, courseinfo.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case courseinfo.FieldClickCount:
		return m.AddedClickCount()
	case courseinfo.FieldLearnCount:
		return m.AddedLearnCount()
	case courseinfo.FieldTotalDuration:
		return m.AddedTotalDuration()
	case courseinfo.FieldSectionCount:
		return m.AddedSectionCount()
	case courseinfo.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case courseinfo.FieldClickCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClickCount(v)
		return nil
	case courseinfo.FieldLearnCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLearnCount(v)
		return nil
	case courseinfo.FieldTotalDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalDuration(v)
		return nil
	case courseinfo.FieldSectionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSectionCount(v)
		return nil
	case courseinfo.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown CourseInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CourseInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseInfoMutation) ResetField(name string) error {
	switch name {
	case courseinfo.FieldClickCount:
		m.ResetClickCount()
		return nil
	case courseinfo.FieldLearnCount:
		m.ResetLearnCount()
		return nil
	case courseinfo.FieldTotalDuration:
		m.ResetTotalDuration()
		return nil
	case courseinfo.FieldSectionCount:
		m.ResetSectionCount()
		return nil
	case courseinfo.FieldPrice:
		m.ResetPrice()
		return nil
	case courseinfo.FieldDetail:
		m.ResetDetail()
		return nil
	case courseinfo.FieldState:
		m.ResetState()
		return nil
	case courseinfo.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case courseinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case courseinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case courseinfo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown CourseInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CourseInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CourseInfo edge %s", name)
}

// CourseSectionMutation represents an operation that mutates the CourseSection nodes in the graph.
type CourseSectionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	title         *string
	_type         *string
	video         *string
	is_deleted    *bool
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CourseSection, error)
	predicates    []predicate.CourseSection
}

var _ ent.Mutation = (*CourseSectionMutation)(nil)

// coursesectionOption allows management of the mutation configuration using functional options.
type coursesectionOption func(*CourseSectionMutation)

// newCourseSectionMutation creates new mutation for the CourseSection entity.
func newCourseSectionMutation(c config, op Op, opts ...coursesectionOption) *CourseSectionMutation {
	m := &CourseSectionMutation{
		config:        c,
		op:            op,
		typ:           TypeCourseSection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseSectionID sets the ID field of the mutation.
func withCourseSectionID(id int) coursesectionOption {
	return func(m *CourseSectionMutation) {
		var (
			err   error
			once  sync.Once
			value *CourseSection
		)
		m.oldValue = func(ctx context.Context) (*CourseSection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CourseSection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourseSection sets the old CourseSection of the mutation.
func withCourseSection(node *CourseSection) coursesectionOption {
	return func(m *CourseSectionMutation) {
		m.oldValue = func(context.Context) (*CourseSection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseSectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseSectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseSectionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseSectionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CourseSection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *CourseSectionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CourseSectionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CourseSectionMutation) ResetTitle() {
	m.title = nil
}

// SetType sets the "type" field.
func (m *CourseSectionMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *CourseSectionMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CourseSectionMutation) ResetType() {
	m._type = nil
}

// SetVideo sets the "video" field.
func (m *CourseSectionMutation) SetVideo(s string) {
	m.video = &s
}

// Video returns the value of the "video" field in the mutation.
func (m *CourseSectionMutation) Video() (r string, exists bool) {
	v := m.video
	if v == nil {
		return
	}
	return *v, true
}

// OldVideo returns the old "video" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldVideo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideo: %w", err)
	}
	return oldValue.Video, nil
}

// ResetVideo resets all changes to the "video" field.
func (m *CourseSectionMutation) ResetVideo() {
	m.video = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *CourseSectionMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *CourseSectionMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *CourseSectionMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseSectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseSectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseSectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseSectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseSectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseSectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CourseSectionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CourseSectionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CourseSectionMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// Where appends a list predicates to the CourseSectionMutation builder.
func (m *CourseSectionMutation) Where(ps ...predicate.CourseSection) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CourseSectionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CourseSection).
func (m *CourseSectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseSectionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.title != nil {
		fields = append(fields, coursesection.FieldTitle)
	}
	if m._type != nil {
		fields = append(fields, coursesection.FieldType)
	}
	if m.video != nil {
		fields = append(fields, coursesection.FieldVideo)
	}
	if m.is_deleted != nil {
		fields = append(fields, coursesection.FieldIsDeleted)
	}
	if m.created_at != nil {
		fields = append(fields, coursesection.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, coursesection.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, coursesection.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseSectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coursesection.FieldTitle:
		return m.Title()
	case coursesection.FieldType:
		return m.GetType()
	case coursesection.FieldVideo:
		return m.Video()
	case coursesection.FieldIsDeleted:
		return m.IsDeleted()
	case coursesection.FieldCreatedAt:
		return m.CreatedAt()
	case coursesection.FieldUpdatedAt:
		return m.UpdatedAt()
	case coursesection.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseSectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coursesection.FieldTitle:
		return m.OldTitle(ctx)
	case coursesection.FieldType:
		return m.OldType(ctx)
	case coursesection.FieldVideo:
		return m.OldVideo(ctx)
	case coursesection.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case coursesection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case coursesection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case coursesection.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CourseSection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseSectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coursesection.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case coursesection.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case coursesection.FieldVideo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideo(v)
		return nil
	case coursesection.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case coursesection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case coursesection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case coursesection.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CourseSection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseSectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseSectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseSectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CourseSection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseSectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseSectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseSectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CourseSection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseSectionMutation) ResetField(name string) error {
	switch name {
	case coursesection.FieldTitle:
		m.ResetTitle()
		return nil
	case coursesection.FieldType:
		m.ResetType()
		return nil
	case coursesection.FieldVideo:
		m.ResetVideo()
		return nil
	case coursesection.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case coursesection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case coursesection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case coursesection.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown CourseSection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseSectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseSectionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseSectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseSectionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseSectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseSectionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseSectionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CourseSection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseSectionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CourseSection edge %s", name)
}

// CourseTeacherMutation represents an operation that mutates the CourseTeacher nodes in the graph.
type CourseTeacherMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	desc          *string
	avatar        *string
	title         *string
	is_deleted    *bool
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	course        map[int]struct{}
	removedcourse map[int]struct{}
	clearedcourse bool
	done          bool
	oldValue      func(context.Context) (*CourseTeacher, error)
	predicates    []predicate.CourseTeacher
}

var _ ent.Mutation = (*CourseTeacherMutation)(nil)

// courseteacherOption allows management of the mutation configuration using functional options.
type courseteacherOption func(*CourseTeacherMutation)

// newCourseTeacherMutation creates new mutation for the CourseTeacher entity.
func newCourseTeacherMutation(c config, op Op, opts ...courseteacherOption) *CourseTeacherMutation {
	m := &CourseTeacherMutation{
		config:        c,
		op:            op,
		typ:           TypeCourseTeacher,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseTeacherID sets the ID field of the mutation.
func withCourseTeacherID(id int) courseteacherOption {
	return func(m *CourseTeacherMutation) {
		var (
			err   error
			once  sync.Once
			value *CourseTeacher
		)
		m.oldValue = func(ctx context.Context) (*CourseTeacher, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CourseTeacher.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourseTeacher sets the old CourseTeacher of the mutation.
func withCourseTeacher(node *CourseTeacher) courseteacherOption {
	return func(m *CourseTeacherMutation) {
		m.oldValue = func(context.Context) (*CourseTeacher, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseTeacherMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseTeacherMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseTeacherMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseTeacherMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CourseTeacher.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CourseTeacherMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CourseTeacherMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CourseTeacher entity.
// If the CourseTeacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseTeacherMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CourseTeacherMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *CourseTeacherMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *CourseTeacherMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the CourseTeacher entity.
// If the CourseTeacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseTeacherMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *CourseTeacherMutation) ResetDesc() {
	m.desc = nil
}

// SetAvatar sets the "avatar" field.
func (m *CourseTeacherMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *CourseTeacherMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the CourseTeacher entity.
// If the CourseTeacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseTeacherMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *CourseTeacherMutation) ResetAvatar() {
	m.avatar = nil
}

// SetTitle sets the "title" field.
func (m *CourseTeacherMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CourseTeacherMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the CourseTeacher entity.
// If the CourseTeacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseTeacherMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CourseTeacherMutation) ResetTitle() {
	m.title = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *CourseTeacherMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *CourseTeacherMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the CourseTeacher entity.
// If the CourseTeacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseTeacherMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *CourseTeacherMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseTeacherMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseTeacherMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CourseTeacher entity.
// If the CourseTeacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseTeacherMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseTeacherMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseTeacherMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseTeacherMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CourseTeacher entity.
// If the CourseTeacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseTeacherMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseTeacherMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CourseTeacherMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CourseTeacherMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CourseTeacher entity.
// If the CourseTeacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseTeacherMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CourseTeacherMutation) ResetDeletedAt() {
	m.deleted_at = nil
}

// AddCourseIDs adds the "course" edge to the Course entity by ids.
func (m *CourseTeacherMutation) AddCourseIDs(ids ...int) {
	if m.course == nil {
		m.course = make(map[int]struct{})
	}
	for i := range ids {
		m.course[ids[i]] = struct{}{}
	}
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *CourseTeacherMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *CourseTeacherMutation) CourseCleared() bool {
	return m.clearedcourse
}

// RemoveCourseIDs removes the "course" edge to the Course entity by IDs.
func (m *CourseTeacherMutation) RemoveCourseIDs(ids ...int) {
	if m.removedcourse == nil {
		m.removedcourse = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.course, ids[i])
		m.removedcourse[ids[i]] = struct{}{}
	}
}

// RemovedCourse returns the removed IDs of the "course" edge to the Course entity.
func (m *CourseTeacherMutation) RemovedCourseIDs() (ids []int) {
	for id := range m.removedcourse {
		ids = append(ids, id)
	}
	return
}

// CourseIDs returns the "course" edge IDs in the mutation.
func (m *CourseTeacherMutation) CourseIDs() (ids []int) {
	for id := range m.course {
		ids = append(ids, id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *CourseTeacherMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
	m.removedcourse = nil
}

// Where appends a list predicates to the CourseTeacherMutation builder.
func (m *CourseTeacherMutation) Where(ps ...predicate.CourseTeacher) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CourseTeacherMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CourseTeacher).
func (m *CourseTeacherMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseTeacherMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, courseteacher.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, courseteacher.FieldDesc)
	}
	if m.avatar != nil {
		fields = append(fields, courseteacher.FieldAvatar)
	}
	if m.title != nil {
		fields = append(fields, courseteacher.FieldTitle)
	}
	if m.is_deleted != nil {
		fields = append(fields, courseteacher.FieldIsDeleted)
	}
	if m.created_at != nil {
		fields = append(fields, courseteacher.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, courseteacher.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, courseteacher.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseTeacherMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case courseteacher.FieldName:
		return m.Name()
	case courseteacher.FieldDesc:
		return m.Desc()
	case courseteacher.FieldAvatar:
		return m.Avatar()
	case courseteacher.FieldTitle:
		return m.Title()
	case courseteacher.FieldIsDeleted:
		return m.IsDeleted()
	case courseteacher.FieldCreatedAt:
		return m.CreatedAt()
	case courseteacher.FieldUpdatedAt:
		return m.UpdatedAt()
	case courseteacher.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseTeacherMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case courseteacher.FieldName:
		return m.OldName(ctx)
	case courseteacher.FieldDesc:
		return m.OldDesc(ctx)
	case courseteacher.FieldAvatar:
		return m.OldAvatar(ctx)
	case courseteacher.FieldTitle:
		return m.OldTitle(ctx)
	case courseteacher.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case courseteacher.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case courseteacher.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case courseteacher.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CourseTeacher field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseTeacherMutation) SetField(name string, value ent.Value) error {
	switch name {
	case courseteacher.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case courseteacher.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case courseteacher.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case courseteacher.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case courseteacher.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case courseteacher.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case courseteacher.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case courseteacher.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CourseTeacher field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseTeacherMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseTeacherMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseTeacherMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CourseTeacher numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseTeacherMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseTeacherMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseTeacherMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CourseTeacher nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseTeacherMutation) ResetField(name string) error {
	switch name {
	case courseteacher.FieldName:
		m.ResetName()
		return nil
	case courseteacher.FieldDesc:
		m.ResetDesc()
		return nil
	case courseteacher.FieldAvatar:
		m.ResetAvatar()
		return nil
	case courseteacher.FieldTitle:
		m.ResetTitle()
		return nil
	case courseteacher.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case courseteacher.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case courseteacher.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case courseteacher.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown CourseTeacher field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseTeacherMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.course != nil {
		edges = append(edges, courseteacher.EdgeCourse)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseTeacherMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case courseteacher.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.course))
		for id := range m.course {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseTeacherMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcourse != nil {
		edges = append(edges, courseteacher.EdgeCourse)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseTeacherMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case courseteacher.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.removedcourse))
		for id := range m.removedcourse {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseTeacherMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcourse {
		edges = append(edges, courseteacher.EdgeCourse)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseTeacherMutation) EdgeCleared(name string) bool {
	switch name {
	case courseteacher.EdgeCourse:
		return m.clearedcourse
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseTeacherMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CourseTeacher unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseTeacherMutation) ResetEdge(name string) error {
	switch name {
	case courseteacher.EdgeCourse:
		m.ResetCourse()
		return nil
	}
	return fmt.Errorf("unknown CourseTeacher edge %s", name)
}
