// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"online-teaching/internal/ent/course"
	"online-teaching/internal/ent/coursechapter"
	"online-teaching/internal/ent/coursecomment"
	"online-teaching/internal/ent/courseinfo"
	"online-teaching/internal/ent/coursesection"
	"online-teaching/internal/ent/courseswiper"
	"online-teaching/internal/ent/predicate"
	"online-teaching/internal/ent/teacher"
	"online-teaching/internal/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCourse        = "Course"
	TypeCourseChapter = "CourseChapter"
	TypeCourseComment = "CourseComment"
	TypeCourseInfo    = "CourseInfo"
	TypeCourseSection = "CourseSection"
	TypeCourseSwiper  = "CourseSwiper"
	TypeTeacher       = "Teacher"
	TypeUser          = "User"
)

// CourseMutation represents an operation that mutates the Course nodes in the graph.
type CourseMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	desc            *string
	image           *string
	tags            *string
	classification  *string
	is_deleted      *bool
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	teachers        map[int]struct{}
	removedteachers map[int]struct{}
	clearedteachers bool
	infos           map[int]struct{}
	removedinfos    map[int]struct{}
	clearedinfos    bool
	chapters        map[int]struct{}
	removedchapters map[int]struct{}
	clearedchapters bool
	sections        map[int]struct{}
	removedsections map[int]struct{}
	clearedsections bool
	swipers         map[int]struct{}
	removedswipers  map[int]struct{}
	clearedswipers  bool
	users           map[int]struct{}
	removedusers    map[int]struct{}
	clearedusers    bool
	done            bool
	oldValue        func(context.Context) (*Course, error)
	predicates      []predicate.Course
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows management of the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for the Course entity.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the ID field of the mutation.
func withCourseID(id int) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Course.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CourseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CourseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CourseMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *CourseMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *CourseMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *CourseMutation) ResetDesc() {
	m.desc = nil
}

// SetImage sets the "image" field.
func (m *CourseMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *CourseMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *CourseMutation) ResetImage() {
	m.image = nil
}

// SetTags sets the "tags" field.
func (m *CourseMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *CourseMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *CourseMutation) ResetTags() {
	m.tags = nil
}

// SetClassification sets the "classification" field.
func (m *CourseMutation) SetClassification(s string) {
	m.classification = &s
}

// Classification returns the value of the "classification" field in the mutation.
func (m *CourseMutation) Classification() (r string, exists bool) {
	v := m.classification
	if v == nil {
		return
	}
	return *v, true
}

// OldClassification returns the old "classification" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldClassification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassification: %w", err)
	}
	return oldValue.Classification, nil
}

// ResetClassification resets all changes to the "classification" field.
func (m *CourseMutation) ResetClassification() {
	m.classification = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *CourseMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *CourseMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *CourseMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddTeacherIDs adds the "teachers" edge to the Teacher entity by ids.
func (m *CourseMutation) AddTeacherIDs(ids ...int) {
	if m.teachers == nil {
		m.teachers = make(map[int]struct{})
	}
	for i := range ids {
		m.teachers[ids[i]] = struct{}{}
	}
}

// ClearTeachers clears the "teachers" edge to the Teacher entity.
func (m *CourseMutation) ClearTeachers() {
	m.clearedteachers = true
}

// TeachersCleared reports if the "teachers" edge to the Teacher entity was cleared.
func (m *CourseMutation) TeachersCleared() bool {
	return m.clearedteachers
}

// RemoveTeacherIDs removes the "teachers" edge to the Teacher entity by IDs.
func (m *CourseMutation) RemoveTeacherIDs(ids ...int) {
	if m.removedteachers == nil {
		m.removedteachers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.teachers, ids[i])
		m.removedteachers[ids[i]] = struct{}{}
	}
}

// RemovedTeachers returns the removed IDs of the "teachers" edge to the Teacher entity.
func (m *CourseMutation) RemovedTeachersIDs() (ids []int) {
	for id := range m.removedteachers {
		ids = append(ids, id)
	}
	return
}

// TeachersIDs returns the "teachers" edge IDs in the mutation.
func (m *CourseMutation) TeachersIDs() (ids []int) {
	for id := range m.teachers {
		ids = append(ids, id)
	}
	return
}

// ResetTeachers resets all changes to the "teachers" edge.
func (m *CourseMutation) ResetTeachers() {
	m.teachers = nil
	m.clearedteachers = false
	m.removedteachers = nil
}

// AddInfoIDs adds the "infos" edge to the CourseInfo entity by ids.
func (m *CourseMutation) AddInfoIDs(ids ...int) {
	if m.infos == nil {
		m.infos = make(map[int]struct{})
	}
	for i := range ids {
		m.infos[ids[i]] = struct{}{}
	}
}

// ClearInfos clears the "infos" edge to the CourseInfo entity.
func (m *CourseMutation) ClearInfos() {
	m.clearedinfos = true
}

// InfosCleared reports if the "infos" edge to the CourseInfo entity was cleared.
func (m *CourseMutation) InfosCleared() bool {
	return m.clearedinfos
}

// RemoveInfoIDs removes the "infos" edge to the CourseInfo entity by IDs.
func (m *CourseMutation) RemoveInfoIDs(ids ...int) {
	if m.removedinfos == nil {
		m.removedinfos = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.infos, ids[i])
		m.removedinfos[ids[i]] = struct{}{}
	}
}

// RemovedInfos returns the removed IDs of the "infos" edge to the CourseInfo entity.
func (m *CourseMutation) RemovedInfosIDs() (ids []int) {
	for id := range m.removedinfos {
		ids = append(ids, id)
	}
	return
}

// InfosIDs returns the "infos" edge IDs in the mutation.
func (m *CourseMutation) InfosIDs() (ids []int) {
	for id := range m.infos {
		ids = append(ids, id)
	}
	return
}

// ResetInfos resets all changes to the "infos" edge.
func (m *CourseMutation) ResetInfos() {
	m.infos = nil
	m.clearedinfos = false
	m.removedinfos = nil
}

// AddChapterIDs adds the "chapters" edge to the CourseChapter entity by ids.
func (m *CourseMutation) AddChapterIDs(ids ...int) {
	if m.chapters == nil {
		m.chapters = make(map[int]struct{})
	}
	for i := range ids {
		m.chapters[ids[i]] = struct{}{}
	}
}

// ClearChapters clears the "chapters" edge to the CourseChapter entity.
func (m *CourseMutation) ClearChapters() {
	m.clearedchapters = true
}

// ChaptersCleared reports if the "chapters" edge to the CourseChapter entity was cleared.
func (m *CourseMutation) ChaptersCleared() bool {
	return m.clearedchapters
}

// RemoveChapterIDs removes the "chapters" edge to the CourseChapter entity by IDs.
func (m *CourseMutation) RemoveChapterIDs(ids ...int) {
	if m.removedchapters == nil {
		m.removedchapters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.chapters, ids[i])
		m.removedchapters[ids[i]] = struct{}{}
	}
}

// RemovedChapters returns the removed IDs of the "chapters" edge to the CourseChapter entity.
func (m *CourseMutation) RemovedChaptersIDs() (ids []int) {
	for id := range m.removedchapters {
		ids = append(ids, id)
	}
	return
}

// ChaptersIDs returns the "chapters" edge IDs in the mutation.
func (m *CourseMutation) ChaptersIDs() (ids []int) {
	for id := range m.chapters {
		ids = append(ids, id)
	}
	return
}

// ResetChapters resets all changes to the "chapters" edge.
func (m *CourseMutation) ResetChapters() {
	m.chapters = nil
	m.clearedchapters = false
	m.removedchapters = nil
}

// AddSectionIDs adds the "sections" edge to the CourseSection entity by ids.
func (m *CourseMutation) AddSectionIDs(ids ...int) {
	if m.sections == nil {
		m.sections = make(map[int]struct{})
	}
	for i := range ids {
		m.sections[ids[i]] = struct{}{}
	}
}

// ClearSections clears the "sections" edge to the CourseSection entity.
func (m *CourseMutation) ClearSections() {
	m.clearedsections = true
}

// SectionsCleared reports if the "sections" edge to the CourseSection entity was cleared.
func (m *CourseMutation) SectionsCleared() bool {
	return m.clearedsections
}

// RemoveSectionIDs removes the "sections" edge to the CourseSection entity by IDs.
func (m *CourseMutation) RemoveSectionIDs(ids ...int) {
	if m.removedsections == nil {
		m.removedsections = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sections, ids[i])
		m.removedsections[ids[i]] = struct{}{}
	}
}

// RemovedSections returns the removed IDs of the "sections" edge to the CourseSection entity.
func (m *CourseMutation) RemovedSectionsIDs() (ids []int) {
	for id := range m.removedsections {
		ids = append(ids, id)
	}
	return
}

// SectionsIDs returns the "sections" edge IDs in the mutation.
func (m *CourseMutation) SectionsIDs() (ids []int) {
	for id := range m.sections {
		ids = append(ids, id)
	}
	return
}

// ResetSections resets all changes to the "sections" edge.
func (m *CourseMutation) ResetSections() {
	m.sections = nil
	m.clearedsections = false
	m.removedsections = nil
}

// AddSwiperIDs adds the "swipers" edge to the CourseSwiper entity by ids.
func (m *CourseMutation) AddSwiperIDs(ids ...int) {
	if m.swipers == nil {
		m.swipers = make(map[int]struct{})
	}
	for i := range ids {
		m.swipers[ids[i]] = struct{}{}
	}
}

// ClearSwipers clears the "swipers" edge to the CourseSwiper entity.
func (m *CourseMutation) ClearSwipers() {
	m.clearedswipers = true
}

// SwipersCleared reports if the "swipers" edge to the CourseSwiper entity was cleared.
func (m *CourseMutation) SwipersCleared() bool {
	return m.clearedswipers
}

// RemoveSwiperIDs removes the "swipers" edge to the CourseSwiper entity by IDs.
func (m *CourseMutation) RemoveSwiperIDs(ids ...int) {
	if m.removedswipers == nil {
		m.removedswipers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.swipers, ids[i])
		m.removedswipers[ids[i]] = struct{}{}
	}
}

// RemovedSwipers returns the removed IDs of the "swipers" edge to the CourseSwiper entity.
func (m *CourseMutation) RemovedSwipersIDs() (ids []int) {
	for id := range m.removedswipers {
		ids = append(ids, id)
	}
	return
}

// SwipersIDs returns the "swipers" edge IDs in the mutation.
func (m *CourseMutation) SwipersIDs() (ids []int) {
	for id := range m.swipers {
		ids = append(ids, id)
	}
	return
}

// ResetSwipers resets all changes to the "swipers" edge.
func (m *CourseMutation) ResetSwipers() {
	m.swipers = nil
	m.clearedswipers = false
	m.removedswipers = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *CourseMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *CourseMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *CourseMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *CourseMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *CourseMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *CourseMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *CourseMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the CourseMutation builder.
func (m *CourseMutation) Where(ps ...predicate.Course) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, course.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, course.FieldDesc)
	}
	if m.image != nil {
		fields = append(fields, course.FieldImage)
	}
	if m.tags != nil {
		fields = append(fields, course.FieldTags)
	}
	if m.classification != nil {
		fields = append(fields, course.FieldClassification)
	}
	if m.is_deleted != nil {
		fields = append(fields, course.FieldIsDeleted)
	}
	if m.created_at != nil {
		fields = append(fields, course.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, course.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldName:
		return m.Name()
	case course.FieldDesc:
		return m.Desc()
	case course.FieldImage:
		return m.Image()
	case course.FieldTags:
		return m.Tags()
	case course.FieldClassification:
		return m.Classification()
	case course.FieldIsDeleted:
		return m.IsDeleted()
	case course.FieldCreatedAt:
		return m.CreatedAt()
	case course.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldName:
		return m.OldName(ctx)
	case course.FieldDesc:
		return m.OldDesc(ctx)
	case course.FieldImage:
		return m.OldImage(ctx)
	case course.FieldTags:
		return m.OldTags(ctx)
	case course.FieldClassification:
		return m.OldClassification(ctx)
	case course.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case course.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case course.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case course.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case course.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case course.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case course.FieldClassification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassification(v)
		return nil
	case course.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case course.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case course.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldName:
		m.ResetName()
		return nil
	case course.FieldDesc:
		m.ResetDesc()
		return nil
	case course.FieldImage:
		m.ResetImage()
		return nil
	case course.FieldTags:
		m.ResetTags()
		return nil
	case course.FieldClassification:
		m.ResetClassification()
		return nil
	case course.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case course.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case course.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.teachers != nil {
		edges = append(edges, course.EdgeTeachers)
	}
	if m.infos != nil {
		edges = append(edges, course.EdgeInfos)
	}
	if m.chapters != nil {
		edges = append(edges, course.EdgeChapters)
	}
	if m.sections != nil {
		edges = append(edges, course.EdgeSections)
	}
	if m.swipers != nil {
		edges = append(edges, course.EdgeSwipers)
	}
	if m.users != nil {
		edges = append(edges, course.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeTeachers:
		ids := make([]ent.Value, 0, len(m.teachers))
		for id := range m.teachers {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeInfos:
		ids := make([]ent.Value, 0, len(m.infos))
		for id := range m.infos {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeChapters:
		ids := make([]ent.Value, 0, len(m.chapters))
		for id := range m.chapters {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeSections:
		ids := make([]ent.Value, 0, len(m.sections))
		for id := range m.sections {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeSwipers:
		ids := make([]ent.Value, 0, len(m.swipers))
		for id := range m.swipers {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedteachers != nil {
		edges = append(edges, course.EdgeTeachers)
	}
	if m.removedinfos != nil {
		edges = append(edges, course.EdgeInfos)
	}
	if m.removedchapters != nil {
		edges = append(edges, course.EdgeChapters)
	}
	if m.removedsections != nil {
		edges = append(edges, course.EdgeSections)
	}
	if m.removedswipers != nil {
		edges = append(edges, course.EdgeSwipers)
	}
	if m.removedusers != nil {
		edges = append(edges, course.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeTeachers:
		ids := make([]ent.Value, 0, len(m.removedteachers))
		for id := range m.removedteachers {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeInfos:
		ids := make([]ent.Value, 0, len(m.removedinfos))
		for id := range m.removedinfos {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeChapters:
		ids := make([]ent.Value, 0, len(m.removedchapters))
		for id := range m.removedchapters {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeSections:
		ids := make([]ent.Value, 0, len(m.removedsections))
		for id := range m.removedsections {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeSwipers:
		ids := make([]ent.Value, 0, len(m.removedswipers))
		for id := range m.removedswipers {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedteachers {
		edges = append(edges, course.EdgeTeachers)
	}
	if m.clearedinfos {
		edges = append(edges, course.EdgeInfos)
	}
	if m.clearedchapters {
		edges = append(edges, course.EdgeChapters)
	}
	if m.clearedsections {
		edges = append(edges, course.EdgeSections)
	}
	if m.clearedswipers {
		edges = append(edges, course.EdgeSwipers)
	}
	if m.clearedusers {
		edges = append(edges, course.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	case course.EdgeTeachers:
		return m.clearedteachers
	case course.EdgeInfos:
		return m.clearedinfos
	case course.EdgeChapters:
		return m.clearedchapters
	case course.EdgeSections:
		return m.clearedsections
	case course.EdgeSwipers:
		return m.clearedswipers
	case course.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeTeachers:
		m.ResetTeachers()
		return nil
	case course.EdgeInfos:
		m.ResetInfos()
		return nil
	case course.EdgeChapters:
		m.ResetChapters()
		return nil
	case course.EdgeSections:
		m.ResetSections()
		return nil
	case course.EdgeSwipers:
		m.ResetSwipers()
		return nil
	case course.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// CourseChapterMutation represents an operation that mutates the CourseChapter nodes in the graph.
type CourseChapterMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	title                 *string
	is_deleted            *bool
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	course_section        map[int]struct{}
	removedcourse_section map[int]struct{}
	clearedcourse_section bool
	done                  bool
	oldValue              func(context.Context) (*CourseChapter, error)
	predicates            []predicate.CourseChapter
}

var _ ent.Mutation = (*CourseChapterMutation)(nil)

// coursechapterOption allows management of the mutation configuration using functional options.
type coursechapterOption func(*CourseChapterMutation)

// newCourseChapterMutation creates new mutation for the CourseChapter entity.
func newCourseChapterMutation(c config, op Op, opts ...coursechapterOption) *CourseChapterMutation {
	m := &CourseChapterMutation{
		config:        c,
		op:            op,
		typ:           TypeCourseChapter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseChapterID sets the ID field of the mutation.
func withCourseChapterID(id int) coursechapterOption {
	return func(m *CourseChapterMutation) {
		var (
			err   error
			once  sync.Once
			value *CourseChapter
		)
		m.oldValue = func(ctx context.Context) (*CourseChapter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CourseChapter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourseChapter sets the old CourseChapter of the mutation.
func withCourseChapter(node *CourseChapter) coursechapterOption {
	return func(m *CourseChapterMutation) {
		m.oldValue = func(context.Context) (*CourseChapter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseChapterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseChapterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseChapterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseChapterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CourseChapter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *CourseChapterMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CourseChapterMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the CourseChapter entity.
// If the CourseChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseChapterMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CourseChapterMutation) ResetTitle() {
	m.title = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *CourseChapterMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *CourseChapterMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the CourseChapter entity.
// If the CourseChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseChapterMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *CourseChapterMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseChapterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseChapterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CourseChapter entity.
// If the CourseChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseChapterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseChapterMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseChapterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseChapterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CourseChapter entity.
// If the CourseChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseChapterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseChapterMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddCourseSectionIDs adds the "course_section" edge to the CourseSection entity by ids.
func (m *CourseChapterMutation) AddCourseSectionIDs(ids ...int) {
	if m.course_section == nil {
		m.course_section = make(map[int]struct{})
	}
	for i := range ids {
		m.course_section[ids[i]] = struct{}{}
	}
}

// ClearCourseSection clears the "course_section" edge to the CourseSection entity.
func (m *CourseChapterMutation) ClearCourseSection() {
	m.clearedcourse_section = true
}

// CourseSectionCleared reports if the "course_section" edge to the CourseSection entity was cleared.
func (m *CourseChapterMutation) CourseSectionCleared() bool {
	return m.clearedcourse_section
}

// RemoveCourseSectionIDs removes the "course_section" edge to the CourseSection entity by IDs.
func (m *CourseChapterMutation) RemoveCourseSectionIDs(ids ...int) {
	if m.removedcourse_section == nil {
		m.removedcourse_section = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.course_section, ids[i])
		m.removedcourse_section[ids[i]] = struct{}{}
	}
}

// RemovedCourseSection returns the removed IDs of the "course_section" edge to the CourseSection entity.
func (m *CourseChapterMutation) RemovedCourseSectionIDs() (ids []int) {
	for id := range m.removedcourse_section {
		ids = append(ids, id)
	}
	return
}

// CourseSectionIDs returns the "course_section" edge IDs in the mutation.
func (m *CourseChapterMutation) CourseSectionIDs() (ids []int) {
	for id := range m.course_section {
		ids = append(ids, id)
	}
	return
}

// ResetCourseSection resets all changes to the "course_section" edge.
func (m *CourseChapterMutation) ResetCourseSection() {
	m.course_section = nil
	m.clearedcourse_section = false
	m.removedcourse_section = nil
}

// Where appends a list predicates to the CourseChapterMutation builder.
func (m *CourseChapterMutation) Where(ps ...predicate.CourseChapter) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CourseChapterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CourseChapter).
func (m *CourseChapterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseChapterMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.title != nil {
		fields = append(fields, coursechapter.FieldTitle)
	}
	if m.is_deleted != nil {
		fields = append(fields, coursechapter.FieldIsDeleted)
	}
	if m.created_at != nil {
		fields = append(fields, coursechapter.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, coursechapter.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseChapterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coursechapter.FieldTitle:
		return m.Title()
	case coursechapter.FieldIsDeleted:
		return m.IsDeleted()
	case coursechapter.FieldCreatedAt:
		return m.CreatedAt()
	case coursechapter.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseChapterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coursechapter.FieldTitle:
		return m.OldTitle(ctx)
	case coursechapter.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case coursechapter.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case coursechapter.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CourseChapter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseChapterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coursechapter.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case coursechapter.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case coursechapter.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case coursechapter.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CourseChapter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseChapterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseChapterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseChapterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CourseChapter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseChapterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseChapterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseChapterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CourseChapter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseChapterMutation) ResetField(name string) error {
	switch name {
	case coursechapter.FieldTitle:
		m.ResetTitle()
		return nil
	case coursechapter.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case coursechapter.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case coursechapter.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CourseChapter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseChapterMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.course_section != nil {
		edges = append(edges, coursechapter.EdgeCourseSection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseChapterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case coursechapter.EdgeCourseSection:
		ids := make([]ent.Value, 0, len(m.course_section))
		for id := range m.course_section {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseChapterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcourse_section != nil {
		edges = append(edges, coursechapter.EdgeCourseSection)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseChapterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case coursechapter.EdgeCourseSection:
		ids := make([]ent.Value, 0, len(m.removedcourse_section))
		for id := range m.removedcourse_section {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseChapterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcourse_section {
		edges = append(edges, coursechapter.EdgeCourseSection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseChapterMutation) EdgeCleared(name string) bool {
	switch name {
	case coursechapter.EdgeCourseSection:
		return m.clearedcourse_section
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseChapterMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CourseChapter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseChapterMutation) ResetEdge(name string) error {
	switch name {
	case coursechapter.EdgeCourseSection:
		m.ResetCourseSection()
		return nil
	}
	return fmt.Errorf("unknown CourseChapter edge %s", name)
}

// CourseCommentMutation represents an operation that mutates the CourseComment nodes in the graph.
type CourseCommentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	username      *string
	comment       *string
	_order        *int
	add_order     *int
	is_show       *bool
	is_deleted    *bool
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CourseComment, error)
	predicates    []predicate.CourseComment
}

var _ ent.Mutation = (*CourseCommentMutation)(nil)

// coursecommentOption allows management of the mutation configuration using functional options.
type coursecommentOption func(*CourseCommentMutation)

// newCourseCommentMutation creates new mutation for the CourseComment entity.
func newCourseCommentMutation(c config, op Op, opts ...coursecommentOption) *CourseCommentMutation {
	m := &CourseCommentMutation{
		config:        c,
		op:            op,
		typ:           TypeCourseComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseCommentID sets the ID field of the mutation.
func withCourseCommentID(id int) coursecommentOption {
	return func(m *CourseCommentMutation) {
		var (
			err   error
			once  sync.Once
			value *CourseComment
		)
		m.oldValue = func(ctx context.Context) (*CourseComment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CourseComment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourseComment sets the old CourseComment of the mutation.
func withCourseComment(node *CourseComment) coursecommentOption {
	return func(m *CourseCommentMutation) {
		m.oldValue = func(context.Context) (*CourseComment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseCommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseCommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseCommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseCommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CourseComment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *CourseCommentMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *CourseCommentMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the CourseComment entity.
// If the CourseComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseCommentMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *CourseCommentMutation) ResetUsername() {
	m.username = nil
}

// SetComment sets the "comment" field.
func (m *CourseCommentMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *CourseCommentMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the CourseComment entity.
// If the CourseComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseCommentMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *CourseCommentMutation) ResetComment() {
	m.comment = nil
}

// SetOrder sets the "order" field.
func (m *CourseCommentMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *CourseCommentMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the CourseComment entity.
// If the CourseComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseCommentMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *CourseCommentMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *CourseCommentMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *CourseCommentMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetIsShow sets the "is_show" field.
func (m *CourseCommentMutation) SetIsShow(b bool) {
	m.is_show = &b
}

// IsShow returns the value of the "is_show" field in the mutation.
func (m *CourseCommentMutation) IsShow() (r bool, exists bool) {
	v := m.is_show
	if v == nil {
		return
	}
	return *v, true
}

// OldIsShow returns the old "is_show" field's value of the CourseComment entity.
// If the CourseComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseCommentMutation) OldIsShow(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsShow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsShow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsShow: %w", err)
	}
	return oldValue.IsShow, nil
}

// ResetIsShow resets all changes to the "is_show" field.
func (m *CourseCommentMutation) ResetIsShow() {
	m.is_show = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *CourseCommentMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *CourseCommentMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the CourseComment entity.
// If the CourseComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseCommentMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *CourseCommentMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseCommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseCommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CourseComment entity.
// If the CourseComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseCommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseCommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseCommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseCommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CourseComment entity.
// If the CourseComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseCommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseCommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the CourseCommentMutation builder.
func (m *CourseCommentMutation) Where(ps ...predicate.CourseComment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CourseCommentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CourseComment).
func (m *CourseCommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseCommentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.username != nil {
		fields = append(fields, coursecomment.FieldUsername)
	}
	if m.comment != nil {
		fields = append(fields, coursecomment.FieldComment)
	}
	if m._order != nil {
		fields = append(fields, coursecomment.FieldOrder)
	}
	if m.is_show != nil {
		fields = append(fields, coursecomment.FieldIsShow)
	}
	if m.is_deleted != nil {
		fields = append(fields, coursecomment.FieldIsDeleted)
	}
	if m.created_at != nil {
		fields = append(fields, coursecomment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, coursecomment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseCommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coursecomment.FieldUsername:
		return m.Username()
	case coursecomment.FieldComment:
		return m.Comment()
	case coursecomment.FieldOrder:
		return m.Order()
	case coursecomment.FieldIsShow:
		return m.IsShow()
	case coursecomment.FieldIsDeleted:
		return m.IsDeleted()
	case coursecomment.FieldCreatedAt:
		return m.CreatedAt()
	case coursecomment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseCommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coursecomment.FieldUsername:
		return m.OldUsername(ctx)
	case coursecomment.FieldComment:
		return m.OldComment(ctx)
	case coursecomment.FieldOrder:
		return m.OldOrder(ctx)
	case coursecomment.FieldIsShow:
		return m.OldIsShow(ctx)
	case coursecomment.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case coursecomment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case coursecomment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CourseComment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseCommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coursecomment.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case coursecomment.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case coursecomment.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case coursecomment.FieldIsShow:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsShow(v)
		return nil
	case coursecomment.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case coursecomment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case coursecomment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CourseComment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseCommentMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, coursecomment.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseCommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coursecomment.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseCommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coursecomment.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown CourseComment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseCommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseCommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseCommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CourseComment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseCommentMutation) ResetField(name string) error {
	switch name {
	case coursecomment.FieldUsername:
		m.ResetUsername()
		return nil
	case coursecomment.FieldComment:
		m.ResetComment()
		return nil
	case coursecomment.FieldOrder:
		m.ResetOrder()
		return nil
	case coursecomment.FieldIsShow:
		m.ResetIsShow()
		return nil
	case coursecomment.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case coursecomment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case coursecomment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CourseComment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseCommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseCommentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseCommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseCommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseCommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseCommentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseCommentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CourseComment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseCommentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CourseComment edge %s", name)
}

// CourseInfoMutation represents an operation that mutates the CourseInfo nodes in the graph.
type CourseInfoMutation struct {
	config
	op                Op
	typ               string
	id                *int
	click_count       *int
	addclick_count    *int
	learn_count       *int
	addlearn_count    *int
	total_duration    *int
	addtotal_duration *int
	section_count     *int
	addsection_count  *int
	price             *float64
	addprice          *float64
	detail            *string
	state             *int
	addstate          *int
	_order            *int
	add_order         *int
	is_quality        *bool
	is_deleted        *bool
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*CourseInfo, error)
	predicates        []predicate.CourseInfo
}

var _ ent.Mutation = (*CourseInfoMutation)(nil)

// courseinfoOption allows management of the mutation configuration using functional options.
type courseinfoOption func(*CourseInfoMutation)

// newCourseInfoMutation creates new mutation for the CourseInfo entity.
func newCourseInfoMutation(c config, op Op, opts ...courseinfoOption) *CourseInfoMutation {
	m := &CourseInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeCourseInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseInfoID sets the ID field of the mutation.
func withCourseInfoID(id int) courseinfoOption {
	return func(m *CourseInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *CourseInfo
		)
		m.oldValue = func(ctx context.Context) (*CourseInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CourseInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourseInfo sets the old CourseInfo of the mutation.
func withCourseInfo(node *CourseInfo) courseinfoOption {
	return func(m *CourseInfoMutation) {
		m.oldValue = func(context.Context) (*CourseInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseInfoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CourseInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClickCount sets the "click_count" field.
func (m *CourseInfoMutation) SetClickCount(i int) {
	m.click_count = &i
	m.addclick_count = nil
}

// ClickCount returns the value of the "click_count" field in the mutation.
func (m *CourseInfoMutation) ClickCount() (r int, exists bool) {
	v := m.click_count
	if v == nil {
		return
	}
	return *v, true
}

// OldClickCount returns the old "click_count" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldClickCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClickCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClickCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClickCount: %w", err)
	}
	return oldValue.ClickCount, nil
}

// AddClickCount adds i to the "click_count" field.
func (m *CourseInfoMutation) AddClickCount(i int) {
	if m.addclick_count != nil {
		*m.addclick_count += i
	} else {
		m.addclick_count = &i
	}
}

// AddedClickCount returns the value that was added to the "click_count" field in this mutation.
func (m *CourseInfoMutation) AddedClickCount() (r int, exists bool) {
	v := m.addclick_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetClickCount resets all changes to the "click_count" field.
func (m *CourseInfoMutation) ResetClickCount() {
	m.click_count = nil
	m.addclick_count = nil
}

// SetLearnCount sets the "learn_count" field.
func (m *CourseInfoMutation) SetLearnCount(i int) {
	m.learn_count = &i
	m.addlearn_count = nil
}

// LearnCount returns the value of the "learn_count" field in the mutation.
func (m *CourseInfoMutation) LearnCount() (r int, exists bool) {
	v := m.learn_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLearnCount returns the old "learn_count" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldLearnCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLearnCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLearnCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLearnCount: %w", err)
	}
	return oldValue.LearnCount, nil
}

// AddLearnCount adds i to the "learn_count" field.
func (m *CourseInfoMutation) AddLearnCount(i int) {
	if m.addlearn_count != nil {
		*m.addlearn_count += i
	} else {
		m.addlearn_count = &i
	}
}

// AddedLearnCount returns the value that was added to the "learn_count" field in this mutation.
func (m *CourseInfoMutation) AddedLearnCount() (r int, exists bool) {
	v := m.addlearn_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLearnCount resets all changes to the "learn_count" field.
func (m *CourseInfoMutation) ResetLearnCount() {
	m.learn_count = nil
	m.addlearn_count = nil
}

// SetTotalDuration sets the "total_duration" field.
func (m *CourseInfoMutation) SetTotalDuration(i int) {
	m.total_duration = &i
	m.addtotal_duration = nil
}

// TotalDuration returns the value of the "total_duration" field in the mutation.
func (m *CourseInfoMutation) TotalDuration() (r int, exists bool) {
	v := m.total_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalDuration returns the old "total_duration" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldTotalDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalDuration: %w", err)
	}
	return oldValue.TotalDuration, nil
}

// AddTotalDuration adds i to the "total_duration" field.
func (m *CourseInfoMutation) AddTotalDuration(i int) {
	if m.addtotal_duration != nil {
		*m.addtotal_duration += i
	} else {
		m.addtotal_duration = &i
	}
}

// AddedTotalDuration returns the value that was added to the "total_duration" field in this mutation.
func (m *CourseInfoMutation) AddedTotalDuration() (r int, exists bool) {
	v := m.addtotal_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalDuration resets all changes to the "total_duration" field.
func (m *CourseInfoMutation) ResetTotalDuration() {
	m.total_duration = nil
	m.addtotal_duration = nil
}

// SetSectionCount sets the "section_count" field.
func (m *CourseInfoMutation) SetSectionCount(i int) {
	m.section_count = &i
	m.addsection_count = nil
}

// SectionCount returns the value of the "section_count" field in the mutation.
func (m *CourseInfoMutation) SectionCount() (r int, exists bool) {
	v := m.section_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSectionCount returns the old "section_count" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldSectionCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSectionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSectionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSectionCount: %w", err)
	}
	return oldValue.SectionCount, nil
}

// AddSectionCount adds i to the "section_count" field.
func (m *CourseInfoMutation) AddSectionCount(i int) {
	if m.addsection_count != nil {
		*m.addsection_count += i
	} else {
		m.addsection_count = &i
	}
}

// AddedSectionCount returns the value that was added to the "section_count" field in this mutation.
func (m *CourseInfoMutation) AddedSectionCount() (r int, exists bool) {
	v := m.addsection_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSectionCount resets all changes to the "section_count" field.
func (m *CourseInfoMutation) ResetSectionCount() {
	m.section_count = nil
	m.addsection_count = nil
}

// SetPrice sets the "price" field.
func (m *CourseInfoMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *CourseInfoMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *CourseInfoMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *CourseInfoMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *CourseInfoMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetDetail sets the "detail" field.
func (m *CourseInfoMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *CourseInfoMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ResetDetail resets all changes to the "detail" field.
func (m *CourseInfoMutation) ResetDetail() {
	m.detail = nil
}

// SetState sets the "state" field.
func (m *CourseInfoMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *CourseInfoMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *CourseInfoMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *CourseInfoMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *CourseInfoMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetOrder sets the "order" field.
func (m *CourseInfoMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *CourseInfoMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *CourseInfoMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *CourseInfoMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *CourseInfoMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetIsQuality sets the "is_quality" field.
func (m *CourseInfoMutation) SetIsQuality(b bool) {
	m.is_quality = &b
}

// IsQuality returns the value of the "is_quality" field in the mutation.
func (m *CourseInfoMutation) IsQuality() (r bool, exists bool) {
	v := m.is_quality
	if v == nil {
		return
	}
	return *v, true
}

// OldIsQuality returns the old "is_quality" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldIsQuality(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsQuality is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsQuality requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsQuality: %w", err)
	}
	return oldValue.IsQuality, nil
}

// ResetIsQuality resets all changes to the "is_quality" field.
func (m *CourseInfoMutation) ResetIsQuality() {
	m.is_quality = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *CourseInfoMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *CourseInfoMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *CourseInfoMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CourseInfo entity.
// If the CourseInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the CourseInfoMutation builder.
func (m *CourseInfoMutation) Where(ps ...predicate.CourseInfo) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CourseInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CourseInfo).
func (m *CourseInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseInfoMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.click_count != nil {
		fields = append(fields, courseinfo.FieldClickCount)
	}
	if m.learn_count != nil {
		fields = append(fields, courseinfo.FieldLearnCount)
	}
	if m.total_duration != nil {
		fields = append(fields, courseinfo.FieldTotalDuration)
	}
	if m.section_count != nil {
		fields = append(fields, courseinfo.FieldSectionCount)
	}
	if m.price != nil {
		fields = append(fields, courseinfo.FieldPrice)
	}
	if m.detail != nil {
		fields = append(fields, courseinfo.FieldDetail)
	}
	if m.state != nil {
		fields = append(fields, courseinfo.FieldState)
	}
	if m._order != nil {
		fields = append(fields, courseinfo.FieldOrder)
	}
	if m.is_quality != nil {
		fields = append(fields, courseinfo.FieldIsQuality)
	}
	if m.is_deleted != nil {
		fields = append(fields, courseinfo.FieldIsDeleted)
	}
	if m.created_at != nil {
		fields = append(fields, courseinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, courseinfo.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case courseinfo.FieldClickCount:
		return m.ClickCount()
	case courseinfo.FieldLearnCount:
		return m.LearnCount()
	case courseinfo.FieldTotalDuration:
		return m.TotalDuration()
	case courseinfo.FieldSectionCount:
		return m.SectionCount()
	case courseinfo.FieldPrice:
		return m.Price()
	case courseinfo.FieldDetail:
		return m.Detail()
	case courseinfo.FieldState:
		return m.State()
	case courseinfo.FieldOrder:
		return m.Order()
	case courseinfo.FieldIsQuality:
		return m.IsQuality()
	case courseinfo.FieldIsDeleted:
		return m.IsDeleted()
	case courseinfo.FieldCreatedAt:
		return m.CreatedAt()
	case courseinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case courseinfo.FieldClickCount:
		return m.OldClickCount(ctx)
	case courseinfo.FieldLearnCount:
		return m.OldLearnCount(ctx)
	case courseinfo.FieldTotalDuration:
		return m.OldTotalDuration(ctx)
	case courseinfo.FieldSectionCount:
		return m.OldSectionCount(ctx)
	case courseinfo.FieldPrice:
		return m.OldPrice(ctx)
	case courseinfo.FieldDetail:
		return m.OldDetail(ctx)
	case courseinfo.FieldState:
		return m.OldState(ctx)
	case courseinfo.FieldOrder:
		return m.OldOrder(ctx)
	case courseinfo.FieldIsQuality:
		return m.OldIsQuality(ctx)
	case courseinfo.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case courseinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case courseinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CourseInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case courseinfo.FieldClickCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClickCount(v)
		return nil
	case courseinfo.FieldLearnCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLearnCount(v)
		return nil
	case courseinfo.FieldTotalDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalDuration(v)
		return nil
	case courseinfo.FieldSectionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSectionCount(v)
		return nil
	case courseinfo.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case courseinfo.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case courseinfo.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case courseinfo.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case courseinfo.FieldIsQuality:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsQuality(v)
		return nil
	case courseinfo.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case courseinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case courseinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CourseInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseInfoMutation) AddedFields() []string {
	var fields []string
	if m.addclick_count != nil {
		fields = append(fields, courseinfo.FieldClickCount)
	}
	if m.addlearn_count != nil {
		fields = append(fields, courseinfo.FieldLearnCount)
	}
	if m.addtotal_duration != nil {
		fields = append(fields, courseinfo.FieldTotalDuration)
	}
	if m.addsection_count != nil {
		fields = append(fields, courseinfo.FieldSectionCount)
	}
	if m.addprice != nil {
		fields = append(fields, courseinfo.FieldPrice)
	}
	if m.addstate != nil {
		fields = append(fields, courseinfo.FieldState)
	}
	if m.add_order != nil {
		fields = append(fields, courseinfo.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case courseinfo.FieldClickCount:
		return m.AddedClickCount()
	case courseinfo.FieldLearnCount:
		return m.AddedLearnCount()
	case courseinfo.FieldTotalDuration:
		return m.AddedTotalDuration()
	case courseinfo.FieldSectionCount:
		return m.AddedSectionCount()
	case courseinfo.FieldPrice:
		return m.AddedPrice()
	case courseinfo.FieldState:
		return m.AddedState()
	case courseinfo.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case courseinfo.FieldClickCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClickCount(v)
		return nil
	case courseinfo.FieldLearnCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLearnCount(v)
		return nil
	case courseinfo.FieldTotalDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalDuration(v)
		return nil
	case courseinfo.FieldSectionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSectionCount(v)
		return nil
	case courseinfo.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case courseinfo.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	case courseinfo.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown CourseInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CourseInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseInfoMutation) ResetField(name string) error {
	switch name {
	case courseinfo.FieldClickCount:
		m.ResetClickCount()
		return nil
	case courseinfo.FieldLearnCount:
		m.ResetLearnCount()
		return nil
	case courseinfo.FieldTotalDuration:
		m.ResetTotalDuration()
		return nil
	case courseinfo.FieldSectionCount:
		m.ResetSectionCount()
		return nil
	case courseinfo.FieldPrice:
		m.ResetPrice()
		return nil
	case courseinfo.FieldDetail:
		m.ResetDetail()
		return nil
	case courseinfo.FieldState:
		m.ResetState()
		return nil
	case courseinfo.FieldOrder:
		m.ResetOrder()
		return nil
	case courseinfo.FieldIsQuality:
		m.ResetIsQuality()
		return nil
	case courseinfo.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case courseinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case courseinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CourseInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CourseInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CourseInfo edge %s", name)
}

// CourseSectionMutation represents an operation that mutates the CourseSection nodes in the graph.
type CourseSectionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	title         *string
	_type         *string
	video         *string
	is_deleted    *bool
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CourseSection, error)
	predicates    []predicate.CourseSection
}

var _ ent.Mutation = (*CourseSectionMutation)(nil)

// coursesectionOption allows management of the mutation configuration using functional options.
type coursesectionOption func(*CourseSectionMutation)

// newCourseSectionMutation creates new mutation for the CourseSection entity.
func newCourseSectionMutation(c config, op Op, opts ...coursesectionOption) *CourseSectionMutation {
	m := &CourseSectionMutation{
		config:        c,
		op:            op,
		typ:           TypeCourseSection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseSectionID sets the ID field of the mutation.
func withCourseSectionID(id int) coursesectionOption {
	return func(m *CourseSectionMutation) {
		var (
			err   error
			once  sync.Once
			value *CourseSection
		)
		m.oldValue = func(ctx context.Context) (*CourseSection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CourseSection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourseSection sets the old CourseSection of the mutation.
func withCourseSection(node *CourseSection) coursesectionOption {
	return func(m *CourseSectionMutation) {
		m.oldValue = func(context.Context) (*CourseSection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseSectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseSectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseSectionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseSectionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CourseSection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *CourseSectionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CourseSectionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CourseSectionMutation) ResetTitle() {
	m.title = nil
}

// SetType sets the "type" field.
func (m *CourseSectionMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *CourseSectionMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CourseSectionMutation) ResetType() {
	m._type = nil
}

// SetVideo sets the "video" field.
func (m *CourseSectionMutation) SetVideo(s string) {
	m.video = &s
}

// Video returns the value of the "video" field in the mutation.
func (m *CourseSectionMutation) Video() (r string, exists bool) {
	v := m.video
	if v == nil {
		return
	}
	return *v, true
}

// OldVideo returns the old "video" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldVideo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideo: %w", err)
	}
	return oldValue.Video, nil
}

// ResetVideo resets all changes to the "video" field.
func (m *CourseSectionMutation) ResetVideo() {
	m.video = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *CourseSectionMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *CourseSectionMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *CourseSectionMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseSectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseSectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseSectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseSectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseSectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseSectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the CourseSectionMutation builder.
func (m *CourseSectionMutation) Where(ps ...predicate.CourseSection) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CourseSectionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CourseSection).
func (m *CourseSectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseSectionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.title != nil {
		fields = append(fields, coursesection.FieldTitle)
	}
	if m._type != nil {
		fields = append(fields, coursesection.FieldType)
	}
	if m.video != nil {
		fields = append(fields, coursesection.FieldVideo)
	}
	if m.is_deleted != nil {
		fields = append(fields, coursesection.FieldIsDeleted)
	}
	if m.created_at != nil {
		fields = append(fields, coursesection.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, coursesection.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseSectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coursesection.FieldTitle:
		return m.Title()
	case coursesection.FieldType:
		return m.GetType()
	case coursesection.FieldVideo:
		return m.Video()
	case coursesection.FieldIsDeleted:
		return m.IsDeleted()
	case coursesection.FieldCreatedAt:
		return m.CreatedAt()
	case coursesection.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseSectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coursesection.FieldTitle:
		return m.OldTitle(ctx)
	case coursesection.FieldType:
		return m.OldType(ctx)
	case coursesection.FieldVideo:
		return m.OldVideo(ctx)
	case coursesection.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case coursesection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case coursesection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CourseSection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseSectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coursesection.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case coursesection.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case coursesection.FieldVideo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideo(v)
		return nil
	case coursesection.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case coursesection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case coursesection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CourseSection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseSectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseSectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseSectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CourseSection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseSectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseSectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseSectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CourseSection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseSectionMutation) ResetField(name string) error {
	switch name {
	case coursesection.FieldTitle:
		m.ResetTitle()
		return nil
	case coursesection.FieldType:
		m.ResetType()
		return nil
	case coursesection.FieldVideo:
		m.ResetVideo()
		return nil
	case coursesection.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case coursesection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case coursesection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CourseSection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseSectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseSectionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseSectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseSectionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseSectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseSectionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseSectionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CourseSection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseSectionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CourseSection edge %s", name)
}

// CourseSwiperMutation represents an operation that mutates the CourseSwiper nodes in the graph.
type CourseSwiperMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	_order        *int
	add_order     *int
	image         *string
	is_show       *bool
	is_deleted    *bool
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CourseSwiper, error)
	predicates    []predicate.CourseSwiper
}

var _ ent.Mutation = (*CourseSwiperMutation)(nil)

// courseswiperOption allows management of the mutation configuration using functional options.
type courseswiperOption func(*CourseSwiperMutation)

// newCourseSwiperMutation creates new mutation for the CourseSwiper entity.
func newCourseSwiperMutation(c config, op Op, opts ...courseswiperOption) *CourseSwiperMutation {
	m := &CourseSwiperMutation{
		config:        c,
		op:            op,
		typ:           TypeCourseSwiper,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseSwiperID sets the ID field of the mutation.
func withCourseSwiperID(id int) courseswiperOption {
	return func(m *CourseSwiperMutation) {
		var (
			err   error
			once  sync.Once
			value *CourseSwiper
		)
		m.oldValue = func(ctx context.Context) (*CourseSwiper, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CourseSwiper.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourseSwiper sets the old CourseSwiper of the mutation.
func withCourseSwiper(node *CourseSwiper) courseswiperOption {
	return func(m *CourseSwiperMutation) {
		m.oldValue = func(context.Context) (*CourseSwiper, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseSwiperMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseSwiperMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseSwiperMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseSwiperMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CourseSwiper.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CourseSwiperMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CourseSwiperMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CourseSwiper entity.
// If the CourseSwiper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSwiperMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CourseSwiperMutation) ResetName() {
	m.name = nil
}

// SetOrder sets the "order" field.
func (m *CourseSwiperMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *CourseSwiperMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the CourseSwiper entity.
// If the CourseSwiper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSwiperMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *CourseSwiperMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *CourseSwiperMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *CourseSwiperMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetImage sets the "image" field.
func (m *CourseSwiperMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *CourseSwiperMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the CourseSwiper entity.
// If the CourseSwiper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSwiperMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *CourseSwiperMutation) ResetImage() {
	m.image = nil
}

// SetIsShow sets the "is_show" field.
func (m *CourseSwiperMutation) SetIsShow(b bool) {
	m.is_show = &b
}

// IsShow returns the value of the "is_show" field in the mutation.
func (m *CourseSwiperMutation) IsShow() (r bool, exists bool) {
	v := m.is_show
	if v == nil {
		return
	}
	return *v, true
}

// OldIsShow returns the old "is_show" field's value of the CourseSwiper entity.
// If the CourseSwiper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSwiperMutation) OldIsShow(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsShow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsShow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsShow: %w", err)
	}
	return oldValue.IsShow, nil
}

// ResetIsShow resets all changes to the "is_show" field.
func (m *CourseSwiperMutation) ResetIsShow() {
	m.is_show = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *CourseSwiperMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *CourseSwiperMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the CourseSwiper entity.
// If the CourseSwiper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSwiperMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *CourseSwiperMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseSwiperMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseSwiperMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CourseSwiper entity.
// If the CourseSwiper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSwiperMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseSwiperMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseSwiperMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseSwiperMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CourseSwiper entity.
// If the CourseSwiper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSwiperMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseSwiperMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the CourseSwiperMutation builder.
func (m *CourseSwiperMutation) Where(ps ...predicate.CourseSwiper) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CourseSwiperMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CourseSwiper).
func (m *CourseSwiperMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseSwiperMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, courseswiper.FieldName)
	}
	if m._order != nil {
		fields = append(fields, courseswiper.FieldOrder)
	}
	if m.image != nil {
		fields = append(fields, courseswiper.FieldImage)
	}
	if m.is_show != nil {
		fields = append(fields, courseswiper.FieldIsShow)
	}
	if m.is_deleted != nil {
		fields = append(fields, courseswiper.FieldIsDeleted)
	}
	if m.created_at != nil {
		fields = append(fields, courseswiper.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, courseswiper.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseSwiperMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case courseswiper.FieldName:
		return m.Name()
	case courseswiper.FieldOrder:
		return m.Order()
	case courseswiper.FieldImage:
		return m.Image()
	case courseswiper.FieldIsShow:
		return m.IsShow()
	case courseswiper.FieldIsDeleted:
		return m.IsDeleted()
	case courseswiper.FieldCreatedAt:
		return m.CreatedAt()
	case courseswiper.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseSwiperMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case courseswiper.FieldName:
		return m.OldName(ctx)
	case courseswiper.FieldOrder:
		return m.OldOrder(ctx)
	case courseswiper.FieldImage:
		return m.OldImage(ctx)
	case courseswiper.FieldIsShow:
		return m.OldIsShow(ctx)
	case courseswiper.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case courseswiper.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case courseswiper.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CourseSwiper field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseSwiperMutation) SetField(name string, value ent.Value) error {
	switch name {
	case courseswiper.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case courseswiper.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case courseswiper.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case courseswiper.FieldIsShow:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsShow(v)
		return nil
	case courseswiper.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case courseswiper.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case courseswiper.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CourseSwiper field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseSwiperMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, courseswiper.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseSwiperMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case courseswiper.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseSwiperMutation) AddField(name string, value ent.Value) error {
	switch name {
	case courseswiper.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown CourseSwiper numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseSwiperMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseSwiperMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseSwiperMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CourseSwiper nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseSwiperMutation) ResetField(name string) error {
	switch name {
	case courseswiper.FieldName:
		m.ResetName()
		return nil
	case courseswiper.FieldOrder:
		m.ResetOrder()
		return nil
	case courseswiper.FieldImage:
		m.ResetImage()
		return nil
	case courseswiper.FieldIsShow:
		m.ResetIsShow()
		return nil
	case courseswiper.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case courseswiper.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case courseswiper.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CourseSwiper field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseSwiperMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseSwiperMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseSwiperMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseSwiperMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseSwiperMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseSwiperMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseSwiperMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CourseSwiper unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseSwiperMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CourseSwiper edge %s", name)
}

// TeacherMutation represents an operation that mutates the Teacher nodes in the graph.
type TeacherMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	desc           *string
	avatar         *string
	title          *string
	is_deleted     *bool
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	courses        map[int]struct{}
	removedcourses map[int]struct{}
	clearedcourses bool
	done           bool
	oldValue       func(context.Context) (*Teacher, error)
	predicates     []predicate.Teacher
}

var _ ent.Mutation = (*TeacherMutation)(nil)

// teacherOption allows management of the mutation configuration using functional options.
type teacherOption func(*TeacherMutation)

// newTeacherMutation creates new mutation for the Teacher entity.
func newTeacherMutation(c config, op Op, opts ...teacherOption) *TeacherMutation {
	m := &TeacherMutation{
		config:        c,
		op:            op,
		typ:           TypeTeacher,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeacherID sets the ID field of the mutation.
func withTeacherID(id int) teacherOption {
	return func(m *TeacherMutation) {
		var (
			err   error
			once  sync.Once
			value *Teacher
		)
		m.oldValue = func(ctx context.Context) (*Teacher, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Teacher.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeacher sets the old Teacher of the mutation.
func withTeacher(node *Teacher) teacherOption {
	return func(m *TeacherMutation) {
		m.oldValue = func(context.Context) (*Teacher, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeacherMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeacherMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeacherMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeacherMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Teacher.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TeacherMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeacherMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeacherMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *TeacherMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *TeacherMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *TeacherMutation) ResetDesc() {
	m.desc = nil
}

// SetAvatar sets the "avatar" field.
func (m *TeacherMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *TeacherMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *TeacherMutation) ResetAvatar() {
	m.avatar = nil
}

// SetTitle sets the "title" field.
func (m *TeacherMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TeacherMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TeacherMutation) ResetTitle() {
	m.title = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *TeacherMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *TeacherMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *TeacherMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TeacherMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeacherMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeacherMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeacherMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeacherMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeacherMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddCourseIDs adds the "courses" edge to the Course entity by ids.
func (m *TeacherMutation) AddCourseIDs(ids ...int) {
	if m.courses == nil {
		m.courses = make(map[int]struct{})
	}
	for i := range ids {
		m.courses[ids[i]] = struct{}{}
	}
}

// ClearCourses clears the "courses" edge to the Course entity.
func (m *TeacherMutation) ClearCourses() {
	m.clearedcourses = true
}

// CoursesCleared reports if the "courses" edge to the Course entity was cleared.
func (m *TeacherMutation) CoursesCleared() bool {
	return m.clearedcourses
}

// RemoveCourseIDs removes the "courses" edge to the Course entity by IDs.
func (m *TeacherMutation) RemoveCourseIDs(ids ...int) {
	if m.removedcourses == nil {
		m.removedcourses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.courses, ids[i])
		m.removedcourses[ids[i]] = struct{}{}
	}
}

// RemovedCourses returns the removed IDs of the "courses" edge to the Course entity.
func (m *TeacherMutation) RemovedCoursesIDs() (ids []int) {
	for id := range m.removedcourses {
		ids = append(ids, id)
	}
	return
}

// CoursesIDs returns the "courses" edge IDs in the mutation.
func (m *TeacherMutation) CoursesIDs() (ids []int) {
	for id := range m.courses {
		ids = append(ids, id)
	}
	return
}

// ResetCourses resets all changes to the "courses" edge.
func (m *TeacherMutation) ResetCourses() {
	m.courses = nil
	m.clearedcourses = false
	m.removedcourses = nil
}

// Where appends a list predicates to the TeacherMutation builder.
func (m *TeacherMutation) Where(ps ...predicate.Teacher) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TeacherMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Teacher).
func (m *TeacherMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeacherMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, teacher.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, teacher.FieldDesc)
	}
	if m.avatar != nil {
		fields = append(fields, teacher.FieldAvatar)
	}
	if m.title != nil {
		fields = append(fields, teacher.FieldTitle)
	}
	if m.is_deleted != nil {
		fields = append(fields, teacher.FieldIsDeleted)
	}
	if m.created_at != nil {
		fields = append(fields, teacher.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, teacher.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeacherMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teacher.FieldName:
		return m.Name()
	case teacher.FieldDesc:
		return m.Desc()
	case teacher.FieldAvatar:
		return m.Avatar()
	case teacher.FieldTitle:
		return m.Title()
	case teacher.FieldIsDeleted:
		return m.IsDeleted()
	case teacher.FieldCreatedAt:
		return m.CreatedAt()
	case teacher.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeacherMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teacher.FieldName:
		return m.OldName(ctx)
	case teacher.FieldDesc:
		return m.OldDesc(ctx)
	case teacher.FieldAvatar:
		return m.OldAvatar(ctx)
	case teacher.FieldTitle:
		return m.OldTitle(ctx)
	case teacher.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case teacher.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case teacher.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Teacher field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeacherMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teacher.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case teacher.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case teacher.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case teacher.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case teacher.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case teacher.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case teacher.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Teacher field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeacherMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeacherMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeacherMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Teacher numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeacherMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeacherMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeacherMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Teacher nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeacherMutation) ResetField(name string) error {
	switch name {
	case teacher.FieldName:
		m.ResetName()
		return nil
	case teacher.FieldDesc:
		m.ResetDesc()
		return nil
	case teacher.FieldAvatar:
		m.ResetAvatar()
		return nil
	case teacher.FieldTitle:
		m.ResetTitle()
		return nil
	case teacher.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case teacher.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case teacher.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Teacher field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeacherMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.courses != nil {
		edges = append(edges, teacher.EdgeCourses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeacherMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teacher.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.courses))
		for id := range m.courses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeacherMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcourses != nil {
		edges = append(edges, teacher.EdgeCourses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeacherMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case teacher.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.removedcourses))
		for id := range m.removedcourses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeacherMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcourses {
		edges = append(edges, teacher.EdgeCourses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeacherMutation) EdgeCleared(name string) bool {
	switch name {
	case teacher.EdgeCourses:
		return m.clearedcourses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeacherMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Teacher unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeacherMutation) ResetEdge(name string) error {
	switch name {
	case teacher.EdgeCourses:
		m.ResetCourses()
		return nil
	}
	return fmt.Errorf("unknown Teacher edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	desc           *string
	avatar         *string
	title          *string
	is_deleted     *bool
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	courses        map[int]struct{}
	removedcourses map[int]struct{}
	clearedcourses bool
	done           bool
	oldValue       func(context.Context) (*User, error)
	predicates     []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *UserMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *UserMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *UserMutation) ResetDesc() {
	m.desc = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
}

// SetTitle sets the "title" field.
func (m *UserMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *UserMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *UserMutation) ResetTitle() {
	m.title = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *UserMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *UserMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *UserMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddCourseIDs adds the "courses" edge to the Course entity by ids.
func (m *UserMutation) AddCourseIDs(ids ...int) {
	if m.courses == nil {
		m.courses = make(map[int]struct{})
	}
	for i := range ids {
		m.courses[ids[i]] = struct{}{}
	}
}

// ClearCourses clears the "courses" edge to the Course entity.
func (m *UserMutation) ClearCourses() {
	m.clearedcourses = true
}

// CoursesCleared reports if the "courses" edge to the Course entity was cleared.
func (m *UserMutation) CoursesCleared() bool {
	return m.clearedcourses
}

// RemoveCourseIDs removes the "courses" edge to the Course entity by IDs.
func (m *UserMutation) RemoveCourseIDs(ids ...int) {
	if m.removedcourses == nil {
		m.removedcourses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.courses, ids[i])
		m.removedcourses[ids[i]] = struct{}{}
	}
}

// RemovedCourses returns the removed IDs of the "courses" edge to the Course entity.
func (m *UserMutation) RemovedCoursesIDs() (ids []int) {
	for id := range m.removedcourses {
		ids = append(ids, id)
	}
	return
}

// CoursesIDs returns the "courses" edge IDs in the mutation.
func (m *UserMutation) CoursesIDs() (ids []int) {
	for id := range m.courses {
		ids = append(ids, id)
	}
	return
}

// ResetCourses resets all changes to the "courses" edge.
func (m *UserMutation) ResetCourses() {
	m.courses = nil
	m.clearedcourses = false
	m.removedcourses = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, user.FieldDesc)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.title != nil {
		fields = append(fields, user.FieldTitle)
	}
	if m.is_deleted != nil {
		fields = append(fields, user.FieldIsDeleted)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldDesc:
		return m.Desc()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldTitle:
		return m.Title()
	case user.FieldIsDeleted:
		return m.IsDeleted()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldDesc:
		return m.OldDesc(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldTitle:
		return m.OldTitle(ctx)
	case user.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case user.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldDesc:
		m.ResetDesc()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldTitle:
		m.ResetTitle()
		return nil
	case user.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.courses != nil {
		edges = append(edges, user.EdgeCourses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.courses))
		for id := range m.courses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcourses != nil {
		edges = append(edges, user.EdgeCourses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.removedcourses))
		for id := range m.removedcourses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcourses {
		edges = append(edges, user.EdgeCourses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeCourses:
		return m.clearedcourses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeCourses:
		m.ResetCourses()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
